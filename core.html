<h2>Core Characteristics</h2>

<section class="normative">
    <h3>Namestring</h3>

    <p>The namestring that identifies this DID method SHALL be: <code>peer</code></p>
    <p>A DID that uses this method MUST begin with the following prefix: <code>did:peer:</code>.
        Per the DID specification, this string MUST be in lowercase. The remainder of the DID, after the prefix,
        is the <a href="#namespace-specific-identifier-nsi">namespace specific identifier described below</a>.
    </p>
    <p class="note">Early feedback on this method suggested that we embed it beneath the namespace of a particular
        blockchain, as in <code>did:sov:peer</code> or <code>did:v1:nym</code>.
        However, this DID method is not captive to any particular blockchain, does not take its resolution rules
        from a parent method, and does not require anchoring or reference to a blockchain to be valid.
        Furthermore, any direct or indirect anchoring of a peer DID to a specific blockchain is driven by
        circumstance and changeable at any time. For example, a peer DID could specify that it is using
        a dead drop on blockchain 1, then change to blockchain 2, then change to blockchains 3 and 4 at
        the same time. Therefore, "peer" belongs at the top of the DID namespace. How this method may be
        used with various blockchains is discussed <a href="#grafting">later</a>.
    </p>
</section>

<section class="normative">
    <h3>Target System(s)</h3>

    <p>This DID method applies to any identity management implementation that meets the following two
        requirements:</p>
    <ul>
        <li><em>Generation Algorithm</em> &mdash; The DIDs are created using the <a href="#namespace-specific-identifier-nsi">
            algorithm described below</a>, endowing them with properties vital to trust between peers that is not
            dependent on a central source of truth.
        </li>
        <li>
            <em>Protocol</em> &mdash; The metadata for DIDs (what would be stored in an on-chain DID doc in other methods)
            is communicated and maintained as described in the <a href="#protocols">Protocols</a> section.
        </li>
    </ul>
</section>

<section class="normative">
    <h3>Namespace Specific Identifier (NSI)</h3>

    <p>The peer DID scheme is defined by the following ABNF (see [[RFC5234]] for syntax):</p>
    <pre class="example" class="ABNF" title="ABNF for peer DIDs">
peer-did = "did:peer:" numalgo encalgo "-" numbasis
numalgo = "1"
encalgo = "1"
numbasis = 64*hex
    </pre>
    <p>The meaning of <code>hex</code> is the traditional one for hexadecimal digits.</p>
    <p>Peer DIDs use an underlying number with high entropy, called the <dfn>numeric basis</dfn>, as the source of their
        uniqueness. This version of the spec requires a 256-bit numeric basis generated from a SHA256 hash
        of the initial content of a DID doc. The <a href="#namestring-generation-method">next section</a> has details.
        The requirement about size and origin of numeric basis is represented in the DID value with <code>numalgo
        </code> == <code>1</code>. Subsequent versions of the spec may describe additional methods of generating the
        numeric basis; each new method is associated with the next unused <code>numalgo</code> digit as it is defined.
    </p>
    <p>This <em>numeric basis</em> is transformed to text using an encoding algorithm. This version of the spec encodes
        using 64 hexadecimal digits, and represents that choice in the DID value with <code>encalgo</code> == <code>1
        </code>. Subsequent versions of the spec may describe additional encodings; each new encoding is associated with
        the next unused <code>encalgo</code> digit as it is defined.</p>
    <p class="note">Implementations of <code>encalgo</code> == <code>1</code> SHOULD render the numeric basis in lower
        case. However, the <code>numbasis</code> portion of peer DIDs MUST be compared according to
        whatever case-sensitivity is implied by the encoding algorithm they use. Hex is not case-sensitive,
        so two peer DID strings using <code>encalgo</code> == <code>1</code>, that differ only in the case
        of the <code>numbasis</code> portion, are equivalent. If a future version of the spec
        defines <code>encalgo</code> == <code>2</code> to be something case-sensitive, such as <a target="_blank"
        href="https://en.bitcoin.it/wiki/Base58Check_encoding">base58</a> or base64 [[RFC4648]], comparison of
        the <code>numbasis</code>values for peer DIDs with <code>encalgo</code> == <code>2</code> will be
        case-sensitive. Therefore, routines that handle peer DIDs MUST NOT normalize or ignore case unless they
        take into account the encoding algorithm of each individual peer DID.</p>
</section>

<section class="normative">
    <h3>Namestring Generation Method</h3>

    <p>The unique <em>numeric basis</em> underlying a Peer DID MUST be generated as follows:</p>
    <ul>
        <li>Create a <dfn>genesis version</dfn> of JSON text of the DID doc for the DID. The genesis version MUST
            include enough keys and <a target="#authorization">authorization</a> that the genesis version of the doc
            can be signed, to prevent man-in-the-middle attacks during initial DID exchange. It SHOULD also include
            enough state that subsequent evolutions to the doc are authorized; otherwise, the doc is a dead end.
            It MUST NOT include the DID itself (either the root <code>id</code> property or its value). This
            lets the doc be created without knowing the DID's value in advance.
            Suppressing the DID value creates a <dfn>stored variant</dfn> of peer DID doc data,
            as opposed to the <dfn>resolved variant</dfn> that would have an actual DID value in the root <code>id
            </code> property. (In either the stored or resolved variant of the doc, anywhere else that the DID value
            would appear, it should appear as a relative reference rather than an absolute value. For example, each
            <code>controller</code> property of a <a href="#publickey">publicKey that is owned by this DID would say
                <code>"controller": "#id"</code></a>.)
        </li>
        <li>Calculate the SHA256 [[!RFC4634]] hash of the bytes of the <a>stored variant</a> of the <a>genesis
            version</a> of the DID doc, and make this value the new DID's <a>numeric basis</a>.
        </li>
    </ul>
    <p>By basing the numeric value of the DID on the <a>genesis version</a> of the DID doc, the DID can begin its
        lifecycle with any number of keys and endpoints, and when the doc is signed or auth-encrypted by one
        of the keys, the recipient can know it has not been modified since creation. This guarantees the
        initial integrity of the DID's chain of custody.</p>
    <p>By hashing the stored variant, we avoid the circular problem of including the DID in the data that's being
        hashed. This means that a peer DID doc must be resolved by converting a <a>stored variant</a> of DID doc
        data into a <a>resolved variant</a> by inserting the value of the DID being resolved, during resolution.</p>
</section>

<section class="informative">
    <h3>Recognizing and handling peer DIDs</h3>

    <p>A valid <code>peer</code> DID might be:</p>

    <pre class="example" title="A typical peer DID">
        <code>did:peer:11-479cbc07c3f991725836a3aa2a581ca2029198aa420b9d99bc0e131d9f3e2cbe</code>
    </pre>

    <p>Peer DIDs consist entirely of printable ASCII characters and are exactly 76 characters long. They have no
        whitespace, and the only punctuation they use are the characters <code>:</code> and <code>-</code>. When
        rendering in columns with a constrained width, they could be hyphenated one or more times as needed, at any
        position after offset 19 (the 7th hex character); the hyphens would not be confused with meaningful delimiters,
        and the final character of the DID would be easy to find. They could also be rendered in a short form with the
        middle of the long hex section elided, if it is not necessary to compare them with precision: <code>
            did:peer:11-479cbc0...f3e2cbe</code>. The ellipsis should not obscure the prefix or the initial 7 or last 7
        characters of the hex, to preserve enough info for casual distinciton. This might be a useful rendering in log
        files, for example.
    </p>

    <p>A convenient regex to match <code>peer</code> DIDs is:</p>

    <pre class="example" title="Matching regex">
^did:peer:(1)(1)-([a-fA-F0-9]{64})$
    </pre>

    <p>A match against this regex places <code>numalgo</code> (the algorithm for choosing a numeric basis) in
        capture group 1, <code>encalgo</code> (the algorithm for encoding) in capture group 2, and the numeric
        basis itself, in properly encoded form, in capture group 3.</p>

    <p>Pseudocode to sort two peer DIDs or test them for equality might be:</p>
    <pre class="example" title="Pseudocode to compare two peer DIDs">
def compare_peer_did(did_a, did_b):
    prefix_a = did_a[:12]
    prefix_b = did_b[:12]
    # Compare the prefix case-sensitively.
    n = cmp(prefix_a, prefix_b)
    if n == 0:
        numeric_a = did_a[12:].lower()
        numeric_b = did_b[12:].lower()
        # Compare the numeric portion case-insensitively.
        n = cmp(numeric_a, numeric_b)
    # Return < 0 if a < b, 0 if a == b, > 0 if a > b
    return n
    </pre>
    <p>More efficient versons of this code could be written; this merely illustrates a correct algorithm.</p>

    <p>Examples of a DID doc for this method are explored in greater detail <a href="#diddocs">below</a>.</p>
</section>
